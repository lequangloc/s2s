TO report
sll_ent


dll-vc06, should be invalid
10 (emp), should be invalid DONE


s2/qf_shls_entl/smallfoot-vc20.tptp.smt2.sl14.sl
checkent[unsat,false] emp & null=null & null!=x1
    |= emp & x2=x2.

RESULT = sat

Wrong Result: Expect unsat, got sat


=================================
#bug/sll-vc01.smt2.sl14


=================================
#bug/bolo-opt1

Case1: valid
ls(x1,x2) * ls(x2, x3) * x3|-> 
  |- ls(x1, x3)  * x3|->

==> RUNFOLD
 ls(x2, x3) * x3|-> 
  |- ls(x2, x3)  * x3|->

x3|->  may be in fp

Case2: invalid
ls(x1,x2) * ls(x2, x3) * ls(x3, x4)
  |- ls(x1, x3)  * ls(x3, x4)

==> RUNFOLD WRONG - UNSOUND
 ls(x2, x3) * ls(x3, x4)
  |- ls(x2, x3)  * ls(x3, x4)


=================================
#bug/

node-dll-rev-dll-entails-dll.smt2.sl14.sl 
dll-spaghetti-existential.smt2.sl14.sl
tll-ravioli-existential.smt2.sl14.sl 

==================================
#dll2-entails-dll2-rev.smt2.sl

quantified, back link for sat

ERROR: at _-1:0_-1:0
Message: error 1: free variables [Anon_38,Anon_39,Anon_40,Anon_41] in pred def DLL2_plus_rev 
Fatal error: exception Failure("error 1: free variables [Anon_38,Anon_39,Anon_40,Anon_41] in pred def DLL2_plus_rev ")


==================================
#bugs/node-dll-rev-dll-entails-dll.smt2.sl

Wrong Result: Expect valid, got invalid

==================================
#bugs/tree-pp-rev-entails-tree-pp.smt2.sl
tree-pp-entails-tree-pp-rev.smt2.sl 

Wrong Result: Expect valid, got unknown



==================================
bugs.

08 DONE
 append-dll,append-sll_cll: classify rec, scc, nonrec
 lsegex4: DO matching prior to linking back. not precise pred ==> do not extend htrue

dll-vc10, eleg : split htrue -> empty and nonemp

dll-vc12: OK

dll-vc06, should be invalid
10 (emp), should be invalid
nll14: invalid (in new benchmark)

nll01. tofix test.sl: incomplete bug in z3 converter
nlcl-01: OK
09: OK

15 DONE: explore all possible searches
16 DONE: proof_size: 3600
20: fix bug on pure-extend: only for precise pred
append-dll-09

skl2-vc04. DONE by fix the detection of precise parameters
skl3-vc02: precise paramters: allow some qvars are not connected. should be null
for completeness.


==================================

#ent-la.sl

- to add matched LHS in a cycle into footprint
- to support linear arith

==================================
#ex7-5

back-link for ex quantified vars

==================================

Elt.eval:
replace predicate occurrences by their base pairs

=================================
#bug/skl2-vc05 DONE

==================================
#bugs/lsegex4-1 DONE

#bugs/lsegex4-2: DONE

TODO: priority complete cyclic than the partial ones
       find cycle until to see a complete one.
=================================
bolo-incomplete2: DONE
bolognesa-14-e08: incomplete

ls(x1,x2) |- ls(x1,x3)

only unfold lHS if x3|->_ or x3=null in LHS

bolognesa-16-e05: incomplete
consider heap disjoint when linking back

==================================
bolo-incomplete3: DONE
To implement pruning condition
for each pred
  (pure, branch)

==================================
ex1-7-8-9: DONE

matching rule

==================================
ex2-10: DONE

take footprint into acc


==================================
# ex2-2

ex in RHS: all possible cases (multiple ctrees)


==================================
#ex3: L unfold
DONE

==================================
#ex3a-2c: DONE

L unfold - R emp

==================================
#ex5-4a: DONE
pred-pred with same root: unfold LHS then match


==================================
#ex10: DONE

to consider deeper footprint for base case.
expect: valid

E4:
id: 9
data: impl exists [u_103]: emp & t!=null && x!=y
   |= emp & x!=t
footprint == bt(t)_0^-1 * x::node<u_103> * lseg(u_103,t)_0^-1
             ^^^^^^^^^^^^^^^
status = invalid
         ^^^^^^^
-----------------------
E5:
id: 9
data: impl exists [u_54]: emp & t!=z && x!=y
   |= emp & x!=t
footprint == lseg(t,z)_0^-1 * x::node<u_54> * lseg(u_54,t)_0^-1
             ^^^^^^^^^^^^^^^^^^^^^
status = invalid

E7: DONE


-----------------------

==================================
#ex11: DONE
problem with unused data field

==================================
#Ex12:
bugs/08

Message: Cpure.type_decomp: no separation on pointer and arith
Fatal error: exception Failure("Cpure.type_decomp: no separation on pointer and arith")


==================================
#Ex13: FIXED

!!! link_back (output) complete:false
Fatal error: exception Not_found

==================================
#ex14: DONE

Fatal error: exception Invalid_argument("index out of bounds")

!!! link_back (bv.PN.hpred_name):binTreeSeg
Fatal error: exception Invalid_argument("List.combine")

==================================
#bugs/02,09,10-12 DONE

02,09: DONE (fresh body variables while unfolding)
10-11: neq_null root


==================================
#bugs/odd-1,4: DONE

odd is in linear compositional fragment

odd-1 :DONE
odd-4 :DONE

==================================
#bugs/dll-vc14

after cycle, the LHS = false, should we link back?
(exists flted_27: dll(x_emp,y_emp,flted_27,z_emp)_0^-1 & flted_27=null && x_emp!=z_emp)


check substitution consistent with equality and neqNULL

==================================
#bugs/spa10-e01.sl

sat -> ent

==================================
#bugs/dll-vc15 [invalid]

proof_search@17
proof_search inp1 :impl exists []: (exists flted_29,flted_30: x2_emp::Dll_t<w2_emp,flted_30> * dll(w2_emp,y2_emp,flted_29,z2_emp)_0^-1 & flted_72=null && flted_30=null && flted_29=null && x_emp!=z_emp && w_emp!=z_emp && y_emp!=z_emp && x2_emp!=w2_emp)
   |= (exists flted_34: dll(z_emp,y_emp,y_emp,z_emp)_3^0 & x2_emp=z2_emp && y2_emp=flted_34 && y_emp!=z_emp && y_emp!=w_emp && w_emp!=z_emp && y_emp!=x_emp && x_emp!=z_emp && y_emp!=flted_72 && flted_72=null && flted_34=null)
footprint == x_emp::Dll_t<w_emp,flted_72> * w_emp::Dll_t<y_emp,x_emp> * y_emp::Dll_t<z_emp,w_emp>

proof_search@17 EXIT:([[],
[(impl exists []: (exists flted_29,flted_30: x2_emp::Dll_t<w2_emp,flted_30> & w2_emp=z2_emp && y2_emp=flted_29 && flted_72=null && flted_30=null && flted_29=null && x_emp!=z_emp && w_emp!=z_emp && y_emp!=z_emp && x2_emp!=w2_emp)
   |= (exists flted_34: dll(z_emp,y_emp,y_emp,z_emp)_3^0 & x2_emp=z2_emp && y2_emp=flted_34 && y_emp!=z_emp && y_emp!=w_emp && w_emp!=z_emp && y_emp!=x_emp && x_emp!=z_emp && y_emp!=flted_72 && flted_72=null && flted_34=null)
footprint == x_emp::Dll_t<w_emp,flted_72> * w_emp::Dll_t<y_emp,x_emp> * y_emp::Dll_t<z_emp,w_emp>
,LUnfold: (dll(w2_emp,y2_emp,flted_29,z2_emp)_0^-1,emp & w2_emp=z2_emp && y2_emp=flted_29)),
(impl exists []: (exists u_159,flted_29,flted_30: w2_emp::Dll_t<u_159,flted_29> * dll(u_159,y2_emp,w2_emp,z2_emp)_1^0 * x2_emp::Dll_t<w2_emp,flted_30> & w2_emp!=z2_emp && y2_emp!=flted_29 && flted_72=null && flted_30=null && flted_29=null && x_emp!=z_emp && w_emp!=z_emp && y_emp!=z_emp && x2_emp!=w2_emp)
   |= (exists flted_34: dll(z_emp,y_emp,y_emp,z_emp)_3^0 & x2_emp=z2_emp && y2_emp=flted_34 && y_emp!=z_emp && y_emp!=w_emp && w_emp!=z_emp && y_emp!=x_emp && x_emp!=z_emp && y_emp!=flted_72 && flted_72=null && flted_34=null)
footprint == x_emp::Dll_t<w_emp,flted_72> * w_emp::Dll_t<y_emp,x_emp> * y_emp::Dll_t<z_emp,w_emp>
,LUnfold: (dll(w2_emp,y2_emp,flted_29,z2_emp)_0^-1,(exists u_159: w2_emp::Dll_t<u_159,flted_29> * dll(u_159,y2_emp,w2_emp,z2_emp)_1^0 & w2_emp!=z2_emp && y2_emp!=flted_29)))]],[])

RHS must be sorted
search for RHS base case unfold or case split x=y \/ x!=y to discard the
middle


==================================
bolognesa-12-e09: DONE

bolo-12-01,08

added matched LHS of bud with comp into
the footprint of the residual entailment
in a cycle

==================================
#sf-vc02

- remove RHS pure (RULE ASSUMPTION).
- not call Z3

==================================
#

To implement
 - L=
 - R=
 s2/qf_shls_entl/smallfoot-vc20.tptp.smt2.sl14.sl
checkent[unsat,false] emp & null=null & null!=x1
    |= emp & x2=x2.

==================================
==================================
